리눅스 디렉터리와 파일 사용하기
============================

# 1. 리눅스 파일의 종류와 특징
## 1.1. 파일의 종류
### 1.1.1. 일반 파일(Regular File)
+ 데이터를 저장하는데 주로 사용
+ 각종 텍스트 파일, 실행 파일, 이미지 파일 등 리눅스에서 사용하는 대부분의 파일은 일반 파일에 해당
+ 실행 파일이나 이미지 파일의 경우 바이너리 형태로 데이터가 저장되어 바이너리 파일이라고 함
+ 텍스트 파일은 문서 편집기를 사용하여 내용을 보거나 편집할 수 있으나, 실행 파일이나 이미지 파일의 경우 해당 파일의 내용을 확인할 수 있는 특정 응용 프로그램이 있어야 확인할 수 있음

### 1.1.2. 디렉터리(Directory)
+ 리눅스에서는 디렉터리도 파일로 취급
+ 디렉터리 파일에는 해당 디렉터리에 저장된 파일이나 하위 디렉터리에 대한 정보가 저장

### 1.1.3. 심볼릭 링크
+ 원본 파일을 대신하여 다른 이름으로 파일명을 지정한 것(윈도의 바로가기와 비슷)

### 1.1.4. 장치파일
+ 리눅스에서는 하드디스크나 키보드 같은 각종 장치도 파일로 취급

### 1.1.5. 파일의 종류 확인: file 명령어
```
[root ~]# file .bash_profile
.bash_profile: ASCII text
[root ~]# file 다운로드
다운로드: directory
[root ~]# file /usr/bin/ls
/usr/bin/ls: ELF 64bit LSB executable,
```

***
# 2. 디렉터리의 종류와 특징
## 2.1. 디렉토리의 종류
###2.1.1. 루트 디렉터리의 서브 디렉터리
```
[root ~]# ls -F /
bin@ dev/ home/ lib64@ media/ opt/ root/ sbin@ sys/ usr/
boot/ etc/ lib@ lost+found/ mnt/ proc/ run/ srv/ tmp/ var/
```
+ / : 해당 파일이 디렉터리임을 표시
+ @ : 심볼릭 링크

### 2.1.2. 작업 디렉터리
+ 현재 사용 중인 디렉터리를 작업 디렉터리(Working directory) 또는 현재 디렉터리(Current directory)라고 함
+ 현재 디렉터리는 '.' 기호로 표시
+ 현재 디렉터리의 위치는 pwd 명령으로 확인

### 2.1.3. 홈 디렉터리
+ 각 사용자에게 할당된 디렉터리로 처음사용자 계정을 만들 때 지정
+ 사용자는 자신의 홈 디렉터리 아래에 파일이나 서브 디렉터리를 생성하며 작업 가능
+ 홈 디렉터리는 '~' 기호로 표시: ~user1

### 2.1.4. 디렉터리의 주요 기능
|디렉터리|기능|
|:---:|---|
|dev|장치 파일이 담긴 디렉터리이다.|
|home|사용자 홈 디렉터리가 생성되는 디렉터리이다.|
|media|시디롬이나 USB 같은 외부 장치를 연결(마운트라고 함)하는 디렉터리이다.|
|opt|추가 패키지가 설치되는 디렉터리이다.|
|root|root 계정의 홈 디렉터리이다. 루트(/) 디렉터리와 다른 것이므로 혼동하지 않도록 한다.|
|sys|리눅스 커널과 관린된 파일이 있는 디렉터리이다.|
|usr|기본 실행 파일과 라이브러리 파일, 헤더 파일 등 많은 파일이 있다. 참고로 usr은 Unix System Resource의 약자이다.|
|boot|부팅에 필요한 커널 파일을 가지고 있다.|
|etc|리눅스 설정을 위한 각종 파일을 가지고 있다.|
|lost+found|리눅스 설정을 위한 각종 파일을 가지고 있다.파일 시스템에 문제가 발생하여 복구할 경우, 문제가 되는 파일이 저장되는 디렉터리로 보통은 비어있다.|
|mnt|파일 시스템을 임시로 마운팅 하는 디렉터리이다.|
|proc|프로세스 정보 등 커널 관련 정보가 저장되는 디렉터리이다.|
|run|실행 중인 서비스와 관련된 파일이 저장된다.|
|srv|FTP나 Web 등 시스템에서 제공하는 서비스의 데이터가 저장된다.|
|tmp|시스템 사용 중에 발생하는 임시 데이터가 저장된다. 이 디렉터리에 있는 파일들은 재부팅 하면 모두 삭제된다.|
|var|시스템 운영 중에 발생하는 데이터나 로그 등이 저장되는 디렉터리이다.|

## 2.2. 디렉터리 내용보기: ls 명령어
### 2.2.1. ls 명령어
+ 디렉터리의 내용을 출력한다.
+ 형식: ls [옵션] [파일 또는 디렉토리명]
+ 옵션
	+ -a : 숨김 파일을 포함하여 모든 파일 목록을 출력한다.
	+ -d : 지정한 디렉터리 자체의 정보를 출력한다.
	+ -i : 첫 번째 행에 inode 번호를 출력한다.
	+ -l : 파일의 상세 정보를 출력한다.
	+ -A : .(마침표)와 ..(마침표 두 개)를 제외한 모든 파일 목록을 출력한다.
	+ -F : 파일의 종류를 표시한다(* : 실행 파일, / : 디렉터리, @ : 심벌릭 링크).
	+ -L : 심벌릭 링크 파일의 경우 원본 파일의 정보를 출력한다.
	+ -R : 하위 디렉터리 목록까지 출력한다.

### 2.2.2. 현재 디렉터리 내용 확인: ls
옵션이나 디렉터리를 지정하니 않고 ls 명령어 사용
```
[root ~]# ls
공개  다운로드  문서  바탕화면  비디오  ...
```

### 2.2.3. 숨김 파일 확인: ls -a
리눅스에서 '.' 으로 시작하면 숨김 파일이며 그냥 ls 명령으로는 볼 수 없음
```
[root ~]# ls -a
. .bashrc  .cache  .config  비디오  ...
```

### 2.2.4. 숨김 파일 확인: ls -F
-F 옵션: 파일의  종류를 구분하여 표시
```
[root ~]# ls -F
공개/  다운로드/  문서/  바탕화면/  비디오/  ...
```
-a 옵션과 연결하여 사용
```
[root ~]# ls -aF
./ .bashrc  .cache/  .config/  비디오/ ...
```

### 2.2.5. 지정한 디렉터리 내용 출력하기
인자로 디렉터리를 지정하면 해당 디렉터리 내용을 출력
```
[root ~]# ls /tmp
pulse-SFQSCP89Eogc      systemd-private-qVL6B0
pulse-ll1JJ5E7GzfF      yum_save_tx.2013-03-16.22-36.5jeP_F.yumtx
systemd-private-7fCx4q  yum_save_tx.2013-03-18.02-42.rS5itA.yumtx
systemd-private-jqJUdd  yum_save_tx.2013-03-18.02-43.XtCWDC.yumtx
```
옵션과 인자를 함께 사용: -F 옵션
```
[root ~]# ls -F /tmp
pulse-SFQSCP89Eogc/      systemd-private-qVL6B0/
pulse-ll1JJ5E7GzfF/      yum_save_tx.2013-03-16.22-36.5jeP_F.yumtx
systemd-private-7fCx4q/  yum_save_tx.2013-03-18.02-42.rS5itA.yumtx
systemd-private-jqJUdd/  yum_save_tx.2013-03-18.02-43.XtCWDC.yumtx
```

### 2.2.6. 상세한 정보 출력하기: -l 옵션
```
[root ~]# ls -l
합계 32
drwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 공개
drwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 다운로드
drwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 문서
...
```

## 2.3. 파일 상세 정보
### 2.3.1. 파일 상세 정보 확인: ls -l 명령어
```
[root ~]# ls -l
합계 32
drwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 공개
drwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 다운로드
drwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 문서
...
```

### 2.3.2. 파일 상세 정보
drwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 공개

|필드 값|의미|
|:---|:---|
|d|파일 종류|
|rwxr-xr-x|접근권한|
|2|하드링크 개수|
|user1|파일 소유자|
|user1|파일이 속한그룹|
|4096|파일크기(바이트)|
|2월 5 22:14|마지막 수정시간|
|공개|파일 이름|

### 2.3.3. 파일 종류
**d** rwxr-xr-x. 2 user1 user1 4096  2월  5 22:14 공개

|문자|파일 종류|
|:---:|---|
|-|일반 파일|
|d|디렉터리|
|l|심벌릭 링크|
|b|블록 장치 파일|
|c|문자 장치 파일|
|p|파이프 파일|
|s|소켓 파일|

***
# 3. 파일 다루기
## 3.1. 파일 내용 연속 출력하기
### 3.1.1. cat 명령어
+ 파일 내용을 출력한다.
+ 형식: cat [옵션] [파일명]
+ 옵션
	+ -n : 행 번호를 붙여서 출력한다.

### 3.1.2. cat 명령어 사용: 파일 내용 확인
/etc/hosts 파일 내용 확인
```
[root ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
```

### 3.1.3. cat 명령어 사용: 행 번호 붙이기
+ 행 번호 붙이기(-n 옵션)
```
[root ~]# cat /etc/hosts
1  127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
2  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
```

## 3.2. 화면 단위로 파일 내용 출력하기
### 3.2.1. more 명령어
+ 파일 내용을 화면 단위로 출력한다.
+ 형식: more [옵션] [파일명]
+ 옵션
	+ ```+``` 행 번호 : 출력을 시작할 행 번호를 지정한다.
+ 아직 출력되지 않은 내용이 더 있으면 화면 하단에 '--More--(0%)'와 같이 표시

### 3.2.2. more 명령어 사용
+ /etc/services 파일 내용 보기
```
[root ~]# more /etc/services
# /etc/services:
# $Id: services,v 1.53 2011/06/13 15:00:06 ovasik Exp $
#
# Network services, Internet style
...
# service-name  port/protocol  [aliases ...]   [# comment]
tcpmux          1/tcp                           # TCP port service multiplexer
--More--(0%)
```

## 3.3. 파일 뒷부분 출력하기
### 3.3.1. tail 명령어
+ 파일의 뒷부분 몇 행을 출력한다.
+ 형식: tail [옵션] [파일명]
+ 옵션
	+ ```+```행 번호 : 지정한 행부터 끝까지 출력한다.
	+ -숫자 : 화면에 출력할 행의 수를 지정한다(기본 값은 10).
	+ -f : 파일 출력이 종료되지 않고 주기적으로 계속 출력한다.

### 3.3.2. tail 명령어 사용
/etc/services 파일의 마지막 10행 출력
```
[root ~]# tail /etc/services
3gpp-cbsp       48049/tcp  # 3GPP Cell Broadcast Service Protocol
isnetserv       48128/tcp  # Image Systems Network Services
isnetserv       48128/udp  # Image Systems Network Services
blp5            48129/tcp  # Bloomberg locator
blp5            48129/udp  # Bloomberg locator
com-bardac-dw   48556/tcp  # com-bardac-dw
com-bardac-dw   48556/udp  # com-bardac-dw
iqobject        48619/tcp  # iqobject
iqobject        48619/udp  # iqobject
matahari        49000/tcp  # Matahari Broker
```

### 3.3.3. tail 명령어 사용: 지정한 숫자만큼 출력하기
+ 지정한 숫자만큼 출력하기: -[숫자 옵션]
```
[root ~]# tail /etc/services
blp5            48129/tcp  # Bloomberg locator
blp5            48129/udp  # Bloomberg locator
com-bardac-dw   48556/tcp  # com-bardac-dw
com-bardac-dw   48556/udp  # com-bardac-dw
iqobject        48619/tcp  # iqobject
iqobject        48619/udp  # iqobject
matahari        49000/tcp  # Matahari Broker
```

### 3.3.4. tail 명령어 사용: 주기적으로 반복 출력하기
+ -f 옵션을 사용하면 파일 출력이 종료되지 않고 대기 상태가 되며 파일 내용이 주기적으로 반복 출력
```
[root ~]# tail /etc/services
3gpp-cbsp       48049/tcp               # 3GPP Cell Broadcast Service Protocol
isnetserv       48128/tcp               # Image Systems Network Services
(생략)
iqobject        48619/udp               # iqobject
matahari        49000/tcp               # Matahari Broker
^C
```

## 3.4. 파일 복사하기
### 3.4.1. cp 명령어
+ 파일이나 디렉터리를 복사한다.
+ 형식: cp [옵션] 파일1/디렉터리1 파일2/디렉터리2
+ 옵션
	+ -i : 대화식 복사 방법으로 파일명2가 이미 존재할 경우 덮어쓸 것인지 물어본다.
	+ -r : 디렉터리를 복사할 때 지정한다.

### 3.4.2. cp 명령어 사용: 두 인자가 모두 파일인 경우
+ /etc/hosts 파일을 현재 디렉터리에 text1 파일로 복사
```
[root ~]# ls
[root ~]# cp /etc/hosts text1
[root ~]# ls
text1
[root ~]#
```

### 3.4.3. cp 명령어 사용: 두 번째 인자가 디렉터리인 경우
파일을 해당 디렉터리 아래에 복사
```
[root ~]# mkdir temp
[root ~]# cp text1 temp
[root ~]# ls temp
text1
[root ~]#
```

원본 파일과 다른 이름으로 복사
```
[root ~]# mkdir temp
[root ~]# cp text1 temp/text2
[root ~]# ls temp
text2
[root ~]#
```

쓰기 권한이 없는 디렉터리에 파일을 복사하려고 하면 다음과 같은 오류가 발생
```
[root ~]# cp text1 /etc
cp: cannot create regular file '/etc/text1': 허가 거부
[root ~]#
```

### 3.4.4. cp 명령어  사용: 인자를 여러 개 지정할 경우
+ cp 명령에서 첫번째 인자의 자리에 파일명을 여러 개 지정할 수 있는데, 두 번째 인자는 반드시 디렉터리여야 한다.
+ 이럴 경우 마지막에 지정한 디렉터리로 앞서 지정한 파일들이 모두 복사된다.
```
[root ~]# mkdir temp
[root ~]# cp /etc/hosts /etc/services temp
[root ~]# ls temp
hosts  services
[root ~]#
```

### 3.4.5. cp 명령어 사용: -i 옵션 사용하기
+ 두 번째 인자로 지정한 파일명이 이미 있는 파일인 경우 덮어서 복사할 것인지 물어봄
```
[root ~]# cp -i /etc/hosts text1
cp: overwrite 'text1'? n
[root ~]#
```


### 3.4.6. cp 명령어 사용: 디렉터리 복사하기
+ 디렉터리를 복사하려명 -r 옵션 사용

-r 옵션을 지정하지 않을 경우
```
[root ~]# cp temp temp2
cp: omitting directory 'temp'
[root ~]#
```

+ 두 번째 인자로 지정한 목적지 디렉터리가 존재하지 않는 경우 새로 생성
+ 디렉터리가 복사되면 원본 디렉터리 아래에 있던 모든 내용도 함께 복사

temp 디렉터리를 temp2 디렉터리로 복사
```
[root ~]# cp -r temp temp2
[root ~]# ls temp2
hosts  services  text1  text2
[root ~]#
```

+ 두 번째 인자로 지정한 디렉터리가 이미 있는 디렉터리일 경우, 원본 디렉터리가 목적지 디렉터리 아래에 원본 디렉터리와 같은 이름으로 복사

temp 디렉터리를 다시 temp2 디렉터리로 복사(이미 앞에서 temp2 디렉터리가 생성되었으므로 이번에는 temp 디렉터리가 temp2 디렉터리 아래에 복사)
```
[root ~]# cp -r temp temp2
[root ~]# ls temp2
hosts  services  temp  text1  text2
[root ~]#
```

## 3.5. 파일 이동하기
### 3.5.1. mv 명령어
+ 파일을 이동한다.
+ 형식: mv [옵션] 파일1/디렉터리1 파일2/디렉터리2
+ 옵션
	+ -i : 파일명2/디렉터리2가 존재하면 덮어쓸 것인지 물어본다.

### 3.5.2. mv 명령어 사용: 파일을 파일로 이동하기
+ 파일을 다른 파일로 이동하는 것은 결국 원본 파일의 파일명을 다른 파일명으로 바꾸는 것
+ 만약 두 번째 인자로 지정한 파일명이 이미 존재하는 파일이면 원본 파일의 내용으로 덮어쓰고 기존의 내용이 삭제
+ 두 번째 인자로 지정한 파일명이 존재하지 않는 파일이라면 새 파일이 생성

text1 파일을 data1 파일로 이동
```
[root ~]# mv text1 data2
[root ~]# ls
data1  data2  temp
[root ~]#
```

### 3.5.3. mv 명령어 사용: 파일을 다른 디렉터리로 이동하기
+ 두 번째 인자로 디렉터리를 지정할 경우 원본 파일을 지정한 디렉터리로 이동

data1 파일을 temp 디렉터리로 이동
```
[root ~]# mv data1 temp
[root ~]# ls
temp  temp2
[root ~]# ls temp
data1  hosts  services  text1  text2
[root ~]#
```

+ 두 번째 인자에 디렉터리와 파일명을 함께 지정할 경우, 파일이 지정한 디렉터리로 이동하면 파일명도 바뀌게 됨
```
[root ~]# cp temp/data1 text1
[root ~]# ls
temp  temp2  text1
[root ~]# mv text1 temp/data2
[root ~]# ls temp
data1  data2  hosts  services  text1  text2
[root ~]#
```

+ 쓰기 권한이 없는 디렉터리로 파일을 이동하려고 할 경우 오류 발생
```
[root ~]# mv temp/data2 /etc
mv: cannot move 'temp/data2' to '/etc/data2': 허가 거부
[root ~]#
```

### 3.5.4. mv 명령어 사용: 파일 여러 개를 디렉터리로 이동하기
+ mv 명령으로 파일 여러 개를 지정한 디렉토리로 한 번에 이동 가능
+ 두 번째 인자는 반드시 디렉터리여야 함
```
[root ~]# ls temp
data1  data2  hosts services  text1  text2
[root ~]# mv temp/data1 temp/data2
[root ~]# ls
data1  data2  temp  temp2
[root ~]# ls temp
hosts  services  text1  text2
[root ~]#
```

### 3.5.5. mv 명령어 사용: -i 옵션 사용하기
+ 두 번째 인자에 지정한 파일명이 기존에 있는 파일일 경우 덮어서 이동할 것인지를 물어봄
```
[root ~]# mv -i data1 data2
mv: overwrite 'data2'? n
[root ~]# n
data1  data2  temp  temp2
[root ~]#
```

### 3.5.6. mv 명령어 사용: 디렉터리를 디렉터리로 이동하기
+ 인자를 모두 디렉터리로 지정하면 디렉터리가 이동
+ 두 번째 인자가 기존에 있던 디렉터리가 아닐 경우에는 디렉터리명이 변경

temp2 디렉터리가 temp3 디렉터리로 이름 변경
```
[root ~]# mv temp2 temp3
[root ~]# ls
data1  data2  temp  temp3
[root ~]#
```

+ 두 번째 인자가 기존에 있던 디렉터리일 경우, 원본 디렉터리가 두 번째 인자로 지정된 디렉터리 아래로 이동

temp3 디렉터리가 temp 디렉터리 아래로 이동
```
[root ~]# ls
data1  data2  temp  temp3
[root ~]# mv temp3 temp
[root ~]# ls
data1  data2  temp
[root ~]# ls temp
hosts  services  temp3  text1  text2
[root ~]#
```

## 3.6. 파일 삭제하기
### 3.6.1. rm 명령어
+ 파일을 삭제한다.
+ 형식: rm [옵션] 파일/디렉터리
+ 옵션
	+ -i : 대화식으로 지정한 파일을 정말 삭제할 겻인지 확인한다.
	+ -r : 디렉터리를 삭제할 때 지정한다.

### 3.6.1. rm 명령어 사용
+ 삭제할 파일을 인자로 지정하면 해당 파일이 삭제
+ 바로 삭제되어 복구할 수도 없으므로 파일을 삭제할 때는 신중해야 함

data2 파일 삭제
```
[root ~]# ls
data1  data2  temp
[root ~]# rm data2
[root ~]# ls
data1  temp
[root ~]#
```

### 3.6.2. rm 명령어 사용: -i 옵션 사용하기
+ -i 옵션을 지정하고 rm 명령을 사용하면 정말 삭제할 것인지 물어봄
```
[root ~]# rm -i data1
rm: remove 일반 파일 'data1'? n
[root ~]# ls
data1  temp
[root ~]#
```

### 3.6.3. rm 명령어 사용: 디렉터리 삭제하기
+ rm 명령으로 디렉터리를 지울 때는 -r 옵션을 지정(삭제된 디렉터리는 복구 불가능)

-r 옵션을 지정하지 않을 경우 오류 메시지 출력
```
[root ~]# cd temp
[root ~]# ls
hosts  services  temp3  text1  text2
[root ~]# rm temp3
rm: cannot remove 'temp3': 디렉터리입니다
[root ~]#
```
